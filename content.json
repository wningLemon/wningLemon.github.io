{"meta":{"title":"WningLemon","subtitle":null,"description":null,"author":"WningLemon","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"整理一些正则和replace的使用","slug":"replace","date":"2019-05-28T03:46:12.000Z","updated":"2019-05-29T01:57:59.244Z","comments":true,"path":"2019/05/28/replace/","link":"","permalink":"http://yoursite.com/2019/05/28/replace/","excerpt":"","text":"replace1.用replace去掉html标签以及空格str.replace(/&lt;img[^&gt;]*&gt;|&lt;\\/?.+?\\/?&gt;|&nbsp;|\\s/gi, ‘’) 2.replace的替换文本函数使用replace(regexp/substr, replacement), replce有两个参数，regexp/substr必需。规定子字符串或要替换的模式的 RegExp 对象。 请注意，如果该值是一个字符串，则将它作为要检索的直接量文本模式，而不是首先被转换为 RegExp 对象；replacement 必需。一个字符串值。规定了替换文本或生成替换文本的函数。 在项目中会很少用到替换文本的函数，没想到用起来还真的挺强大的，比如在给上传的图片添加缩略的时候，图片地址url_200x300.png这样的格式我们可能需要将图片的后置去掉，然后拼接上图片缩略图的参数，然后在拼上图片的后缀，无疑需要indexOf一下，substring一下等等，用replace的替换文本函数就很容易了 1234let regx = /\\.(JPG|JPEG|PNG|BMP)$/gi let content = url.replace(regx, (m)=&gt;&#123; return '_200x300' + m&#125;) 效果如图： 3取出富文本框中的全部图片在富文本中无论是上传的图片还是复制粘贴过来，其实无非就是img标签，利用正则将图片全部取出，利用正则匹配图片的img标签12let reg = /&lt;img[^&gt;]*&gt;/gilet arr = data.match(reg) 利用match会返回一个数组 4.用正则表达式匹配身份证12let rep = /(^[1-9]\\d&#123;5&#125;(18|19|([23]\\d))\\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\\d&#123;3&#125;[0-9Xx]$)|(^[1-9]\\d&#123;5&#125;\\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\\d&#123;2&#125;$)/; rep.test(val) 符合将返回true否则返回false","categories":[],"tags":[]},{"title":"用reduce对比两个数组的差异","slug":"reduce","date":"2019-05-27T09:40:59.000Z","updated":"2019-05-28T09:56:39.419Z","comments":true,"path":"2019/05/27/reduce/","link":"","permalink":"http://yoursite.com/2019/05/27/reduce/","excerpt":"","text":"假如有两个数组pre、cur,比较两个数组之间的差异，比如在pre中但不在cur数组中，在cur数组中不在pre数组中，这个时候会想到用filter过滤返回一个新的数组，filter的条件为pre数组是否cur数组的某一项，可以写成： 123456var pre = [1, 2, 3, 4, 5]var current = [3, 4, 5, 6, 7]var diff = pre.filter(item =&gt; !current.includes(item))console.log(diff) =&gt; [1,2] 大佬说这样的时间负责度太高了，于是乎亮出大招： 123456789var bMap = current.reduce((map, i) =&gt; &#123; map[i] = 1 return map&#125;, &#123;&#125;) var b = pre.filter(item =&gt; !bMap[item])console.log(b)=&gt; [1,2] 生成哈希表，哈希表的寻址是直接性的，不需要for循环遍历，includes需要每次遍历成哈希表以后节省了遍历，所以速度比较快 arr.reduce(function(prev,cur,index,arr){…}, init);有四个参数prev 表示上一次调用回调时的返回值，或者初始值 init;cur 表示当前正在处理的数组元素;index 表示当前正在处理的数组元素的索引，若提供 init 值，则索引为0，否则索引为1;init 表示初始值。通常情况会用到前两个参数。 那么在秀刀操作中，使用了前两个参数，初始值为一个空对象，其实就会将数组变成的值变成一个键值对的形式，1就是给对象的属性复制，这里也可以写成true比较好理解，最后在通过对象的方式去寻找。 如果是一个对象数组呢，我们就需要绑定对象中唯一值：比如：12345var bMap = arr1.reduce((map, i) =&gt; &#123; map[i.userId] = true; return map; &#125;, &#123;&#125;); var result = arr2.filter(item =&gt; !bMap[item.userId]); 如果有两个对象数组，分别数组a与b中的差异，就可以将上边的代码封装为一个方法： 12345678splitCaptainList(arr1, arr2) &#123; var bMap = arr1.reduce((map, i) =&gt; &#123; map[i.userId] = true; return map; &#125;, &#123;&#125;); var result = arr2.filter(item =&gt; !bMap[item.userId]); return result &#125; 如果你有什么更好的方法或者文章有不正确的内容，很开心能跟你交流，QQ:39004003 [笑脸]","categories":[],"tags":[]},{"title":"利用map解构返回数据格式","slug":"map-note","date":"2019-05-05T10:14:40.000Z","updated":"2019-05-24T09:55:30.808Z","comments":true,"path":"2019/05/05/map-note/","link":"","permalink":"http://yoursite.com/2019/05/05/map-note/","excerpt":"","text":"有的时候后端返回的字段并不是我们需要的，比如1.渲染一个select，那么option接受的属性名称是固定的，2.或者有一个可复用的列表页，可复用的列表将不改变模板中的变量，那么就需要在调用接口的地方将返回的数据名称进行改变 很简单，我们利用map对返回结果进行操作，map不会改变原数组会生成一个新的数组 1let newArr = arr.map(it =&gt; (&#123;value:it.subjectType, label:it.subjectName&#125;)) ***注意：箭头函数若返回结果是一个对象时一定要添加括号结果如下： ***注意：箭头函数若只有一个参数的时候可以不用添加括号1let newArr = arr.map((&#123;subjectType,subjectName&#125;) =&gt; (&#123;value:subjectType,label:subjectName&#125;))","categories":[],"tags":[]},{"title":"动态改变组件的keepAlive的值","slug":"keepAlive","date":"2019-03-12T07:30:21.000Z","updated":"2019-03-13T05:15:21.470Z","comments":true,"path":"2019/03/12/keepAlive/","link":"","permalink":"http://yoursite.com/2019/03/12/keepAlive/","excerpt":"","text":"keepAlive的作用还是很大的，虽然在之前的总结中有说避开使用keepAlive,但是在app端的表单页面难免会有跳转到其他页面进行选择然后再返回到表单页面，虽然通过主子路由的方式，但是页面返回后表单并没有保存填过的信息。 首先在app.vue根组件中， 12345678&lt;template v-if=\"$route.meta.keepAlive\"&gt; &lt;keep-alive&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/template&gt; 是渲染组件（可以理解为此处是你的a.vue, b.vue等等），所以不难理解，若是组件在路由中定义时加上了keepAlive并且为true的情况下，那么该组件有将引入的keep-alive组件。 在路由文件中这么写：123456&#123; name: 'create', path: '/create', meta: &#123;title: '会议详情', keepAlive: true&#125;, component: resolve =&gt; &#123;require.ensure(['../pages/create.vue'], () =&gt; &#123;resolve(require('../pages/create.vue'))&#125;)&#125;&#125;, 在meta对象中添加keepAlive属性为true。 通常情况下查看详情页和创建页面为一个，某些操作隐藏掉而已，所以会遇到一个问题，从列表页查看详情的时候，因为该页面添加了keep-alive组件，所以详情页并不会重新渲染，无论点击哪条进来详情都是第一页的内容。 那么既然是路由中设置了keepAlive属性的问题，那就看看能不能动态改变。那么在进入创建页面的时候也就是离开上一个页面的时候能不能改变create页面的keepAlive属性呢。 所以就在创建的页面之前的页面使用路由钩子函数这样处理： 123456beforeRouteLeave (to, from, next) &#123; if(this.isKeep) &#123; to.meta.keepAlive = true &#125; else to.meta.keepAlive = false next()&#125; 那到底是什么原因添加了keep-alive组件之后，组件将不会渲染，也只能用路由钩子函数来改变吗？所以又尝试了一下，那么每个组件都有生命周期函数，created、mounted、activated、distroyed，那么页面第一次进来的时候，created、mounted、activated都将打印，但是当第二次在进到创建页面的时候created、mounted钩子函数并没有执行，但是执行了activated钩子函数，所以说除了上边的处理方式以外，我们还可以将页面初始化的函数放在activated一份。 如果你有什么更好的方法或者文章有不正确的内容，很开心能跟你交流，QQ:39004003 [笑脸]","categories":[],"tags":[]},{"title":"vue自定义指令","slug":"directive-defined","date":"2019-03-11T08:02:22.000Z","updated":"2019-03-12T07:29:19.483Z","comments":true,"path":"2019/03/11/directive-defined/","link":"","permalink":"http://yoursite.com/2019/03/11/directive-defined/","excerpt":"","text":"vue中不止有v-if、v-else、v-model这样的指令，可自定义指令。项目中有一个搜索页面，进去之后获取焦点，使用input的autofocus属性，很奇怪的是第一次焦点在，但是第二次焦点就获取不上了。这个问题也一直没有找到原因，还在找原因，项目急就用了自定义指令的方法。自己定义一下focus。有两种方式注册指令，一种是全局的一种是在组件内的（在组件内注册就类似于watch、filter的用法）。 注册全局组件 123456789import Vue from 'vue'Vue.directive('focus', &#123; // 当被绑定的元素插入到 DOM 中时…… inserted: function (el) &#123; // 聚焦元素 el.focus() &#125;&#125;) 注册局部（组件内）12345678directives: &#123; focus: &#123; // 指令的定义 inserted: function (el) &#123; el.focus() &#125; &#125;&#125; 在绑定函数的地方，传入一个参数el，el便是添加指令的地方获取的dom元素，比如说将该指令添加在input输入框中，那么el便是获取该DOM元素，所以若是想要改变元素的样式或者内容等等，可以写成el.style.color或el.innerHtml，等等一系列的DOM操作。 然后在模板中使用该指令：1&lt;input type=\"text\" v-model=\"inputValue\" placeholder=\"搜索\" v-focus&gt; 这样就无论如何input输入框一直都是在focus的状态了。","categories":[],"tags":[]},{"title":"如何设置Mint UI中Picker中的默认值","slug":"mint-picker","date":"2019-03-11T02:23:41.000Z","updated":"2019-03-11T07:59:38.939Z","comments":true,"path":"2019/03/11/mint-picker/","link":"","permalink":"http://yoursite.com/2019/03/11/mint-picker/","excerpt":"","text":"第一步：引入组件js部分引入依赖123import &#123; Popup, Picker&#125; from \"mint-ui\";Vue.component(Switch.name, Switch);Vue.component(Popup.name, Popup); 在模板中引入1234&lt;mt-popup v-model=\"remindVisible\" position=\"bottom\" class=\"remind-popup\"&gt; &lt;mt-picker :slots=\"Minuteslots\" @change=\"onRemindChange\" :show-toolbar=\"true\" v-model=\"remindMin\"&gt; &lt;/mt-picker&gt;&lt;/mt-popup&gt; 能够从上边的代码可以看出picker结合了popup使用。在使用picker的时候，有一个参数为slots，这个参数就是picker的备选值都有哪些，同时可以设置picker默认选中项，那么slots的参数在data中是这样设置的：12345678910export default &#123; data () &#123; return &#123; Minuteslots: [&#123; values: ['未设置', '15分钟', '60分钟', '一天'], defaultIndex: 1 &#125;] &#125; &#125;&#125; 其中defaultIndex就是默认值的在values中的index值，言外之意就是picker默认选中的就是’15分钟’。有一个问题就是如果是一个提交信息的页面，并且还可以提交后进行编辑，那么将返回的数据为picker的默认值，这个时候就用到双向绑定,v-model了，设置了一个remindMin变量，因为后端返回的数据和前端picker显示的不同，所以使用computed进行转换，并改变defaultIndex来改变picker中的默认值（picker中高亮的部分） 12345678910111213141516171819202122232425computed: &#123; remindMin () &#123; switch(this.formObj.remindMinute) &#123; case 0: this.Minuteslots[0].defaultIndex = 0 return '未设置' break; case 15: this.Minuteslots[0].defaultIndex = 1 return '15分钟' break; case 60: this.Minuteslots[0].defaultIndex = 2 return '60分钟' break; case 1440: this.Minuteslots[0].defaultIndex = 3 return '一天' break; default: return this.formObj.remindMinute break; &#125; &#125; &#125; 那么就做到了，当有后端返回的时候，我们通过计算属性来改变当前的默认值以及显示。 如果你有什么更好的方法，很开心能跟你交流，QQ:39004003 [笑脸]","categories":[],"tags":[]},{"title":"iView表单循环表单验证","slug":"review-note12","date":"2019-01-22T08:00:08.000Z","updated":"2019-01-23T03:33:04.106Z","comments":true,"path":"2019/01/22/review-note12/","link":"","permalink":"http://yoursite.com/2019/01/22/review-note12/","excerpt":"","text":"PC端现在用的最多的组件库就是iView，通常我们都是一个表单验证后就提交了，如果是动态新添加的表单，如何做验证并提交呢。首先先看一下要实现的样子： 你会发现，两个表单在分别点击完成的时候都分别作了验证。 iView的Form表单，需要两个属性，rule是表单验证规则，比如该字段是否需要必填等，即使是循环动态生成的表单，若是相同的表单项，那么验证规则一定是一样的，所以rule所关联的就是一个变量；还有一个属性model是表单数据对象，那么我们既然是循环生成的表单，并且每一次点击完成的时候是提交当前的表格的数据，所以我们想到model是循环生成表单的list的某一项，那么我们就可以定义变量了： 12345678910111213141516171819202122// 表单验证规则uploadFormRule: &#123; mechanismAddress: [ &#123; required: true, message: '请输入服务机构地址', trigger: 'blur' &#125;], mechanismName: [ &#123; required: true, message: '请输入服务机构名称', trigger: 'blur' &#125;], mechanismPhone: [ &#123; required: true, message: '请输入手机号', trigger: 'blur' &#125;, &#123; pattern: /^(\\d&#123;11&#125;|\\d&#123;3&#125;-\\d&#123;8&#125;)$/, message: '请输入正确的联系方式', trigger: 'blur' &#125; ], mechanismUrl: [ &#123; type: 'url', message: '请输入正确的服务机构网址', trigger: 'blur' &#125; ]&#125;,list: [ &#123; mechanismAddress: \"\", mechanismName: \"\", mechanismPhone: \"\", mechanismUrl: \"\" &#125;] 那么循环表单的时候就可以写成(忽略一些样式所需要的元素)： 1&lt;Form v-for=\"(li, index) in list\" :key=\"index\" :rules=\"uploadFormRule\" :model=\"li\"&gt;&lt;/Form&gt; 那么现在就是最重要的问题了，我们知道如果是当个表单验证的时候就是 12this.$refs[name].validate((valid) =&gt; &#123;&#125;)// name指的是model所对应的对象名字 那么this.$ref是获取注册过的组件，所以需要使用ref来注册组件，通常单表单注册的时候就是model所关联的对象，但是是循环生成的表单并且都需要验证，那ref就需要换一个写法，ref是一个对象，也就是说点击完成的时候我们验证的是当前的这个表单，所以ref需要关联当前的index,所以表单写成： 12345&lt;Form v-for=\"(li, index) in list\" :key=\"index\" :rules=\"uploadFormRule\" :model=\"li\" :ref=\"'list' + index\"&gt;&lt;/Form&gt;// 当然ref里边list可以替换成想要的字符串，比如li// 验证表单的时候：let form = 'list' + indexthis.$refs[form][0].validate((valid) =&gt; &#123;&#125;) 之所以这样写，把refs打印出来是这样的 页面有几个表单，就注册了几个表单，refs是一个对象，注册时使用ref=”‘list’ + index”来命名每一个表单，自然取出时也需要拼接这样的一个字符串，从上图中可以看出，每一个ref对象（每一个表单项都一个数组），打印一下我们可以看出，我们每个表单所对应的model绑定数据对象以及rule 总结：循环表单验证的时候注册组件时主要加上该表单的唯一标识，index或者key","categories":[],"tags":[]},{"title":"命名视图","slug":"review-note11","date":"2019-01-18T08:23:06.000Z","updated":"2019-01-22T02:00:14.616Z","comments":true,"path":"2019/01/18/review-note11/","link":"","permalink":"http://yoursite.com/2019/01/18/review-note11/","excerpt":"","text":"有的时候有的页面需要左侧的菜单栏或者头部，但是有的页面不需要，那么该如何根据不同的页面是否显示左侧的菜单栏呢。想一想我们设置每个页面的title的时候，都在定义路由的时候设置的，所以能不能在meta中新添加一个属性，通过该属性来判断是都显示菜单呢。 首先在router.js中配置路由123456789101112&#123; name: 'super', path: '/super', meta: &#123;title: '超管首页', showMenu: false&#125;, component: resolve =&gt; &#123;require.ensure(['../pages/superAdmin/super.vue'], () =&gt; &#123;resolve(require('../pages/superAdmin/super.vue'))&#125;)&#125;&#125;,&#123; name: 'card', path: '/card', meta: &#123;title: '景区名片', showMenu: true, href: '/card'&#125;, component: resolve =&gt; &#123;require.ensure(['../pages/card/card.vue'], () =&gt; &#123;resolve(require('../pages/card/card.vue'))&#125;)&#125;&#125;， 我们在meta对象中新增加属性showMenu，需要左侧菜单栏的时候设置false,不需要时设置为true,那么我们的app.vue是这样的 1234567891011&lt;!-- 左侧 --&gt;&lt;div class=\"main-left-menu\" v-if=\"$route.meta.showMenu\"&gt; &lt;div v-for=\"(menu, index) in menuList\" :key=\"index\" :class=\"['tab-left', &#123;active: hrefStr == menu.href&#125;]\" @click=\"showList(menu, index)\"&gt;&#123;&#123;menu.name&#125;&#125;&lt;/div&gt;&lt;/div&gt;&lt;!-- 内容区域 --&gt;&lt;div :class=\"&#123;'main-body': $route.meta.showMenu&#125;\"&gt; &lt;template&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/template&gt;&lt;/div&gt; 我们通过判断路由的meta的showMenu属性判断是否加载菜单 定义css样式 12345678910111213141516171819202122232425262728.main-left-menu&#123; position: absolute; top:60px; bottom: 0; width: 240px; background:#3D436A; overflow: auto; .tab-left &#123; font-size: 20px; line-height: 20px; padding:10px; color: #fff; margin-bottom: 10px; cursor: pointer; &#125; .active &#123; background: #49507C; &#125;&#125;.main-body&#123; position: absolute; left: 240px; top:60px; right: 0; bottom: 0; background:#eee; overflow: auto;&#125; 从上边的css可以看出，那么被选中的tab页签，改变样式并跳转路由，首次进入的时候，我们通过当前的href来判断到底是哪个页面，渲染视图，那么需要定义一个左侧菜单栏的循环数组，数组如下：1234567891011121314 menuList: [ &#123; name: '景区名片', href: '/card' &#125;, &#123; name: '景区相册', href: '/photo' &#125;, &#123; name: '旅游服务机构', href: '/org' &#125;] 能看出定义的href属性恰恰就是router.js中的路由地址，然后我们通过当前的地址（location.href）判断是哪个路由，添加active类，mounted代码如下： 12let href = location.href.substring(location.href.lastIndexOf('#')+1)this.hrefStr = href 然后点击左侧的菜单切换路由，添加一个方法为： 1234showList (menu, index) &#123; this.hrefStr = menu.href this.$router.push(&#123;path: menu.href&#125;)&#125; 别以为完事了哦，有一个坑就是，如果用浏览器的回退按钮时，会发现，虽然页面跳转了，但是左侧菜单的状态并没有改变，只有刷新的时候才可以，所以才需要添加一个监听 12345watch: &#123; '$route.meta.href' (val) &#123; this.hrefStr = val &#125;&#125; 这下就完美了，最后来一张效果图：","categories":[],"tags":[]},{"title":"微信朋友圈全文、收起功能实现","slug":"review-note10","date":"2019-01-18T01:48:53.000Z","updated":"2019-01-22T07:56:33.652Z","comments":true,"path":"2019/01/18/review-note10/","link":"","permalink":"http://yoursite.com/2019/01/18/review-note10/","excerpt":"","text":"需求是这样的，一个列表页，每个条目最多只显示两行文字，超过两行显示省略号，并显示向下箭头，点击箭头展示全部内容。 刚接触这个需求的时候，也想了几种方案，如果用字符长度来判断是否显示箭头和省略号是最简单的，但是体验一定不好，首先手机屏幕的大小不确定，每个不同型号的手机一行显示多少个字符不确定，再加上有英文单词和数字的时候就更不能确定了。 css3里边有一个-webkit-line-clamp:2;这样的一个属性，当然也要搭配一些其他的属性。 那么就算是超过部分用省略号代替已经解决了，那么点击箭头展示全部怎么解决呢，动态改变css样式，那么一定需要一个状态值来判断，这个状态值就由js来做吧。这是初步想法。 看一下实现后的样子： ① 可以看到若是文字超过两行显示向下的箭头，省略号代替其他部分② 若文字没有超过两行不显示箭头不显示省略号③ 点击向下的箭头，显示该条的全部内容，箭头向上，点击向上箭头收起内容 那么现在我们看到是一个列表，布局就用ul li，因为列表里边既有一行的时候也有两行的时候，所以我给了li一个padding，然后里边放一个div，这个div里边包括文字和箭头。所以html是这样写的： 12345678&lt;ul&gt; &lt;li :class=\"&#123;'limit': item.state&#125;\" ref=\"li\" v-for=\"(item, index) in zcList.data\" @click.stop=\"zcNameC(item)\" :key=\"index\"&gt; &lt;div :class=\"['content', &#123;'content-limit': item.state&#125;]\"&gt; &lt;div class=\"content-msg\"&gt;&#123;&#123;item.content&#125;&#125;&lt;/div&gt; &lt;span v-if=\"moreArr[index]\" :class=\"item.state ? 'arrowdown': 'arrowtop'\" @click.stop=\"deploy(item, index)\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;/li&gt;&lt;/ul&gt; 对应的css样式是这样的：12345678910111213141516171819202122232425262728293031323334li &#123; padding: 10px 15px 10px 0; position:relative; font-size: 1.5rem; text-align: left; line-height: 2.4rem;&#125;.limit &#123; max-height: 70px; overflow: hidden; text-overflow:ellipsis; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 2; &#125;.content&#123; width: 100%; position: relative;&#125;.content-limit&#123; max-height: 50px; overflow: hidden;&#125;.content-msg&#123; padding-right: 44px;&#125;.arrowdown&#123; background: url(&quot;../assets/down.png&quot;) no-repeat; background-size: 10px 6px; &#125;.arrowtop&#123; background: url(&quot;../assets/top.png&quot;) no-repeat; background-size: 10px 6px; &#125; 可以看出来我们需要两个变量，一个moreArr数组来判断是否显示箭头，一个是每一个条目有一个箭头的状态是向上还是向下，项目太久，现在想完全可以使用一个状态来判断是否显示箭头。 js代码如下：1234567891011setTimeout(() =&gt; &#123; let lis = document.getElementsByClassName('content-msg') for (let i = 0; i &lt; lis.length; i++) &#123; if (lis[i].offsetHeight / 24 &gt; 2) &#123; this.moreArr.push(true) this.$set(this.zcList.data[i], 'state', true) &#125; else &#123; this.moreArr.push(false) &#125; &#125;&#125;) 首先我们需要判断当前每个条目是否超过了两行，因为每行字有一行高，那么可以用包裹文字的div的高度除以每行字的行高，24px是每一行字的行高，若是大于2(依情况而定)，那么需要给当前对象添加箭头，那么就在moreArr中添加一个true，并且将列表项添加state属性并为true 注意：一定要加setTimeout或者nextTick，先请求接口才能去获取包裹文字的div不然获取不到。因为我在请求接口的时候使用async await 将请求接口变成异步操作了，所以要把上边的方法变成异步的 那么点击箭头的时候就改变state的状态就好了，代码如下12345deploy (item, index) &#123; if (item.hasOwnProperty('state')) &#123; item.state = !item.state &#125;&#125; 那么有了这个经验来写微信的全文查看以及收起全文就简单很多了，先看一下效果 左边的图是没有点开全文的时候，右边是点开的时候。这个是类似于朋友圈的功能，上拉加载下一页，所以在请求接口后都要计算再次渲染的条目的高度。 123456789101112131415161718192021222324252627282930313233343536373839&lt;div :class=\"['con-outer',&#123;'con-box': li.state&#125; ]\"&gt; &lt;p class=\"content-msg\" v-html=\"$options.filters.toHtml(li.content)\"&gt;&lt;/p&gt;&lt;/div&gt;&lt;div&gt;&lt;span v-show=\"moreArr[li.id]\" class=\"btn-show\" @click.stop=\"deploy(li,index)\"&gt;&#123;&#123;li.state ? '全文':'收起'&#125;&#125;&lt;/span&gt;&lt;/div&gt;.con-outer&#123; position:relative; font-size: 15px; color: #666666; line-height: 21px; word-break:break-all; text-align: justify; padding-left: 15px;&#125;.con-box&#123; max-height: 104px; overflow: hidden; text-overflow:ellipsis; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 5;&#125;getStatus () &#123; setTimeout(() =&gt; &#123; let lis = document.getElementsByClassName('content-msg') for (let i = 0; i &lt; lis.length; i++) &#123; let item = this.list[i] if (!item.state) &#123; if (lis[i].offsetHeight / 21 &gt; 5.1) &#123; this.$set(item, 'state', true) &#125; else &#123; this.$set(item, 'state', false) &#125; this.moreArr[item.id] = item.state &#125; &#125; &#125;)&#125; 嗯哼，有分页，所以想每次添加state的状态的时候就只遍历新增加的条目，然而踩了好多坑。其实这个项目做了太久了快两年了，不记得当时踩了哪些坑然后这样写了， 最近有同事问起来，所以想着总结一下","categories":[],"tags":[]},{"title":"map方法","slug":"review-note8","date":"2019-01-15T02:24:02.000Z","updated":"2019-01-16T08:24:39.335Z","comments":true,"path":"2019/01/15/review-note8/","link":"","permalink":"http://yoursite.com/2019/01/15/review-note8/","excerpt":"","text":"1.返回新数组map和forEach都是遍历数组中的每一项，某种意义上告别了for循环。map与forEach支持三个参数，分别为item（数组中的每一项），index（每一项在数组中的索引），arr（数组本身），参数顺序不能错。map与forEach不同的是map遍历数组可以有返回值，如： 遍历数据，将每一项除以2，并返回，这时候打印发现是一个新的数组，这个新数组由原数组元素对应的回调函数的返回值构成。若没有返回值，则新数组的所有元素为undefined。虽然返回一个新的数组，但是并不会覆盖原数组。用同样的方法，用forEach试一遍：这时候打印就是undefined了，也就是说forEach只是数组中的每一项。 2.替换原数组我们可以通过map返回一个新的数组的特性，替换原来数组，如： 3.改变键值(key)如果我们封装类似于下拉框的组件，根据不同配置调用不同的接口，组件中双向绑定的键值是不会变的，不然也达不到封装组件的意义了。那么获取人员列表的时候后端返回username，userId，获取部门列表的时候返回partname，partId，那么根据组件的要求，我们要将字段名称改成label与value。如果说只需要用label与value的话，那么可以写成：1this.list = data.map((&#123;id, name&#125;) =&gt; (&#123;label: name, value: id&#125;)) 先将map中的item进行解构，箭头函数若省略return的话加一个()。那么上边写的是你已经确定后端一定会返回id，name的时候，上边说的场景是后端接口返回的key是不确定的，所以我们需要写一个方法。123changeFieldName (name1, name2, arr) &#123; this.list= arr.map((item) =&gt; (&#123;label: item[name1], value: item[name2]&#125;))&#125;","categories":[],"tags":[]},{"title":"主子路由你想不到的用处","slug":"review-note7","date":"2018-12-29T06:39:26.000Z","updated":"2019-01-09T14:35:51.484Z","comments":true,"path":"2018/12/29/review-note7/","link":"","permalink":"http://yoursite.com/2018/12/29/review-note7/","excerpt":"","text":"vue是单页面应用，只有一个跟组件App.vue，在index.js入口文件中引用需要的一些组件并把app.vue根组件渲染在index.html中。我是这样理解的,app.vue、index.html和index.js之间的关系的。我们会看到app.vue中只有一个，每次跳转理由只是加载不同的组件而已。会遇到一个场景，比如有一个新闻列表页，点进去一条新闻，那么我们希望返回的时候，页面还会在我刚才点进去那条的状态，但是组件切换一定不能保存状态，当然可以使用虽然有了这个组件，但是你不知道你什么时候会遇到坑，那不妨试试路由的方式吧。 主子路由又叫嵌套，一个路由嵌套另一个路由，被嵌套的路由为子路由。当一个模板中与子路由有很多相似的地方的时候可以使用主子路由的形式。首先需要在主路由组件中添加渲染模板 ,在路由index.js文件中配置子路由1234567891011&#123; name: 'success', path: '/success', meta: &#123;title: '成功页面', keepAlive: true&#125;, component: resolve =&gt; &#123;require.ensure(['../pages/success/success.vue'], () =&gt; &#123;resolve(require('../pages/success/success.vue'))&#125;)&#125;, children: [&#123; path: '/success1', meta: &#123;title: '成功页面1', keepAlive: true&#125;, component: resolve =&gt; &#123;require.ensure(['../pages/success/success1.vue'], () =&gt; &#123;resolve(require('../pages/success/success1.vue'))&#125;)&#125;, &#125;]&#125; 在主路由中添加children属性，在该属性下配置子路由，最后在主路由跳转的时候，写法如下：1this.$router.push(`$&#123;this.$route.fullPath&#125;/success1`) 通过this.$route下的fullPath属性主组件的路由并拼接子路由的地址，访问子路由的时候一定是加上主路由的地址。在子组件中改变了主组件中的变量，我们可以通过this.$parent.par的方式获取在主路由组件中定义的变量，不用通过路由进行将传递进行传递。并且通过主子路由的方式进行跳转，可以直接通过.this.$route.back()的方式直接回到主路由。注意：如果路由1嵌套了路由2，路由2嵌套了路由3，那么被嵌套的子路由就直接在它的主路由中进行配置就行了，如下：12345678910111213141516&#123; name: 'success', path: '/success', meta: &#123;title: '成功页面', keepAlive: true&#125;, component: resolve =&gt; &#123;require.ensure(['../pages/success/success.vue'], () =&gt; &#123;resolve(require('../pages/success/success.vue'))&#125;)&#125;, children: [&#123; path: '/success1', meta: &#123;title: '成功页面1', keepAlive: true&#125;, component: resolve =&gt; &#123;require.ensure(['../pages/success/success1.vue'], () =&gt; &#123;resolve(require('../pages/success/success1.vue'))&#125;)&#125;, children: [&#123; path: '/success2', meta: &#123;title: '成功页面2', keepAlive: true&#125;, component: resolve =&gt; &#123;require.ensure(['../pages/success/success1.vue'], () =&gt; &#123;resolve(require('../pages/success/success2.vue'))&#125;)&#125; &#125;] &#125;]&#125;","categories":[],"tags":[{"name":"主子路由","slug":"主子路由","permalink":"http://yoursite.com/tags/主子路由/"}]},{"title":"sessionStorage与localStorage的区别","slug":"review-note6","date":"2018-12-05T09:31:26.000Z","updated":"2018-12-05T09:48:28.648Z","comments":true,"path":"2018/12/05/review-note6/","link":"","permalink":"http://yoursite.com/2018/12/05/review-note6/","excerpt":"","text":"HTML5 的 DOM Storage 机制提供了一种方式让程序员能够把信息存储到本地的计算机上，在需要时获取。这点和 cookie 相似，区别是 DOM Storage 提供了更大容量的存储空间。以前在客户端保存数据使用最多的是 cookie，但 cookie 的大小上限为 4KB，虽然sessionStorage和localStorage也有限制，但是比cookie大的多，并且每次请求一个新页面时 cookie 都会被发送过去，无形中浪费带宽。 在项目中不同组件需要相同的一些数据，通过路由传来传去，还得在不同路由中需要定义参数进行接收，无疑在不同组件中定义了很多变量，若是放在全局，并不能清除掉，无疑浪费资源。可以通过Storage机制存在客户端，不同路由就直接取即可，那么需要考虑使用两种对象使用哪一种。 （1）区别 sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的。通过以上的不同点，在本项目中使用session来进行存取，只在一次会话中进行存取。 （2）存取方法 12sessionStorage.setItem(\"key\", \"value\"); localStorage.setItem(\"key\", \"value\");sessionStorage.getItem(\"key\", \"value\"); localStorage.getItem(\"key\", \"value\"); （3）保存在 Storage 对象的数据类型当使用 DOM Storage 进行本地存储时，任何数据格式在 Storage 对象中都以字符串类型保存，所以如果保存的数据不是字符串，在读取的时候需要自己进行类型的转换。这里我们使用 JSON 将对象序列化之后再存储。在项目中其中有一个对象需要存入到缓存中： 1sessionStorage.setItem('textarea', this.textarea) This.textarea是我在组件中定义的一个对象，但是在 Storage 对象中都以字符串类型保存，所以在Application中查看的时候是这样的： 所以在存session的时候需要进行转换，如下：1sessionStorage.setItem('textarea', JSON.stringify(this.textarea)) 现在存的session是一个字符串了，所以在取出session值得时候依然需要转换，转换成原来的数据类型格式，如下：JSON.parse() 函数会把 JSON 对象转换为原来的数据类型。","categories":[],"tags":[]},{"title":"代码提交、vscode的使用","slug":"review-note5","date":"2018-12-05T07:33:42.000Z","updated":"2018-12-05T08:53:32.915Z","comments":true,"path":"2018/12/05/review-note5/","link":"","permalink":"http://yoursite.com/2018/12/05/review-note5/","excerpt":"","text":"在项目开发中学会提交代码是不能缺少的技能之一。首先是在本地创建git仓库，如果是单纯自己的文件想要上传到github上的话，在需要上传的文件的文件夹右键菜单中有一个选项”git Bash Here”打开git控制台输入”git init”这时候会发现所在的文件夹多出一个文件，如图： 看到.git文件就是本地仓库已经创建好了。如果是开发项目的情况下，将项目从远程下载下来可以通过git clone的方式，如： 首先进入到项目将要放置的地址，然后执行git clone命令，通过这种方式既可以把远程项目下载到本地也可以在项目中创建本地仓库。两种创建本地仓库的方式。 下面就是进入到项目的开发阶段，为了不破坏master主干上的代码，需要先创建自己的开发分支。 第一步：创建分支dev分支 git branch dev 第二步： 切换到dev分支 git checkout dev 前两步操作可以一步操作进行： git checkout -b dev 加上-b参数表示创建并切换分支 第三步：提交文件，提交文件分为两步， ①git add 文件名 或者是 git add * （提交文件夹中的所有文件） //将文件提交到暂存区，并没有提交到远程 ②git commit -m “message” //将文件提交到本地仓库 -m参数用于添加提交文件的备注信息 ③将文件提交到远程 git push 以上这么麻烦的命令行，让我能够知道提交代码发生的过程，目前在开发项目中用vscode编辑器，提交代码再也不用担心，如果要提交代码时，首先选择自己的开发分支，界面左下角的位置在界面顶部弹出框中选择分支或创建分支，界面左下角显示当前分支，如下图： 第二步，提交文件时点击界面左侧菜单栏分支按钮，显示有几个文件有更改，右侧显示更改的文件名称， 第三步，提交文件时在上图的文件列表上部添加提交备注，同事按住ctrl+enter键提交，通过git status命令查看提交状态， 提示提交信息成功。","categories":[],"tags":[]},{"title":"调试工具的使用","slug":"review-note4","date":"2018-11-23T03:37:13.000Z","updated":"2018-12-04T03:24:14.745Z","comments":true,"path":"2018/11/23/review-note4/","link":"","permalink":"http://yoursite.com/2018/11/23/review-note4/","excerpt":"","text":"开发怎么能离开调试工具，感谢浏览器的开发者调试工具，不墨迹来了。 1.F12调试1、打开开发者调试工具 通过以下方式打开开发者调试工具： ① 在网页上右键选择“检查” ② 快捷键 F12 ③ Ctrl+shift+i ④ 找到浏览器右上角的三个点，找到更多工具，然后选择开发者工具开发者调试工具打开后的，如图： 2.导航条部分功能使用 ①快速找到页面中某个节点，利用导航条最左端的小图标点击后变成蓝色，在界面的左侧就是“页面显示部分”鼠标停留的部分会变成高亮，点击时“调试工具显示部分”会显示被点击的节点的dom元素会高亮显示以及显示样式，如图: 过开发者调试工具可以模拟移动端的界面，找到导航条中选中元素图标右边的矩形叠加小图标，点击，页面显示部分显示移动端的样式，如图：③ 在①的图中看到开发者调试工具的页面看到是在右侧，在导航条部门找到三个点（不是浏览器的点），在弹出框部门选择模式，如图：当前是在右侧，第一个是调试工具界面与页面显示部分分离出来。 3.Elements的使用在导航条中选择Elements，在标号为1的区域显示dom树结构，2区域显示样式，3为盒子模型，最中间显示的是左侧页面显示部分高亮元素的宽和高，绿色部分是pading的值，其次黄色是border和橙色是margin。 在标号为2的区域中elements.style添加样式，可以在线调试样式，在该处添加样式会直接添加到行内样式中，所以优先级最高，如果在文件中已经定义了样式，不生效，在此处添加生效，那就要需要查看在页面中添加样式的优先级问题了。 还可以通过Elements下载图片，找到图片的对应的节点，鼠标悬在图片节点上，会显示该图片，如下图，在图片的地址位置右键，在弹出的菜单选项中选择open in new tabs这样该图片显示new一个新的窗口页，即可下载 4.console的使用通常情况下我们想要打印一些信息就在页面中写console.log(data)等显示在此处，除此之外，也可以查看一些基础的知识或者演示一些代码，如：返回了window下的所有属性，或者知识演示一些代码，如图:熟知的是console.log()打印一般的日志，还有console.error()显示带有红色小图标的红色错误信息，console.warn()显示带有黄色小图标的警告信息。如图： 5.Sources的使用可以在这个面板显示当前项目的结构，选择一个项目可以进行调试js代码，如图:左侧显示项目的结构，我们通过该面板本地的js代码，也可以调试远程的js代码，可以通过选择文件的名字打开文件或者用面板中间部分提示的快捷键打开文件，打开 一个文件，在面板的中间部分，显示全部文件信息，可以通过点击在js部分每行前边的序号添加断点，如图：刷新页面后：在执行第一个断点的方法时，页面显示部分如上图左侧显示，右侧画框的部分显示全部的断点，在一个断点的时候，可以通过查看变量的值，如;将鼠标悬在左侧红色的框内，则会显示该变量的值，也可以通过在右侧的watch里添加需要监听的变量，点击加号，输入需要观察的变量名称后回车，即添加成功，若该变量实时变化watch中的变量也会实时变化，也可以添加多个需要监听的变量。同样也可以通过在source面板中添加自己的debugger代码。在面板的右上角有这样的几个小图标，分别是:第1个：放行，停止该行代码的调试第2个：不跳入函数中去，继续执行下一行代码（F10）第3个：跳入函数中去（F11）第4个：从执行的函数中跳出第5个：禁用所有的断点，不做任何调试第6个：程序运行时遇到异常时是否中断的开关 6.Network的使用在进行向接口请求数据或者提交数据的时候，需要使用到network面板，如： 目前network监听全部的请求，在面板左侧选择要查看的接口，点击后，可以看到面板右侧Headers的内容，包括一些请求地址、http请求状态，请求头以及传递的参数，提交数据的时候避免是出错要认真核对，切换选项卡到preview，查看接口返回的数据，如图： 在这里师父交了一个大招，就是在监听media类型的时候，点击qq或者网易云音乐的音乐文件时候，在请求列表会显示请求的音乐，open in new tabs后既可以下载音乐了，再也不用买会员啦。 ##7.Application的使用在Application可以查看存在浏览器中的全局信息，如图：用到最多的就是左侧红色圈住的部分，当前查看的是存在localstorage中的信息，如上图的右侧，无论是哪一种存储机制，都是键值对的形式。 8.附加插件的使用项目开发使用vue框架，在chrome扩展插件中安装vue插件何乐而不为呢。首先利用蓝灯翻墙，然后在chrome的应用中搜索vue，如图： 并选择添加，添加成功后，刷新浏览器，会在导航条部分出现Vue切换了，切换到vue面板中，如图：在面板左侧显示，当前页面中所有的组件，便是App.vue根组件，所有的组件都渲染在根组件的中，展开的箭头，会看到app下所有组件的名称，选择一个组件查看，可以查看到右侧的该组件的信息。也可以切换查看该组件的企业信息，比如Vuex状态管理器中的数据或者查看组件都执行了哪些事件，使vue的开发更加方便。","categories":[],"tags":[]},{"title":"路由传参的几种方式","slug":"review-note2","date":"2018-11-22T09:31:37.768Z","updated":"2018-11-22T11:28:25.277Z","comments":true,"path":"2018/11/22/review-note2/","link":"","permalink":"http://yoursite.com/2018/11/22/review-note2/","excerpt":"","text":"组件跳转的时候，下一个组件有的时候会需要前一个页面的一些参数。比如说相同的组件但是要根据不同的角色请求不同的接口等等。有几种路由传递参数的方式： （1）通过url路径来传递参数(不太知道如何定义类型)那么通过url路径在浏览器中显示为：http://localhost:8079/#/detail/333detail是我要跳转的页面/后面333就是我要传递的参数，若是使用这种方式来传递参数的时候，我们需要在路由的文件中来修改一下12// detail后面添加/:id, id代表传过来的参数名为id&#123; path: '/detail/:id', name: 'detail', meta: &#123;title: '办事详情'&#125;, component: detail &#125; 在跳转路由的时候有两种方式：123this.$router.push(&#123;path: '/detail/333'&#125;); // 在js的方法中&lt;router-link :to=\"&#123;path: '/detail/333'&#125;\"&gt;&lt;/router-link&gt; // 在组件中使用&lt;router-link&gt;标签 那么我们在detail组件中通过以下的方式来获取参数id的值1this.$route.params.id *注意：路由跳转的时候是router，获取路由参数的时候是route （2）通过query来传递参数通过query传递参数的时候，在浏览器显示则为：http://localhost:8079/#/detail?id=333会拼接在url的问号后面，这种方式不用修改路由的文件，写成：1&#123; path: '/detail', name: 'detail', meta: &#123;title: '办事详情'&#125;, component: detail &#125;, 那么在跳转路由的时候写成：1this.$router.push(&#123;path: '/detail', query: &#123;id: 333&#125;&#125;); 在获取参数id的时候，写法如下：1this.$route.query.id （2）通过pararms来传递参数通过pararms传递参数的时候，在浏览器显示则为：http://localhost:8079/#/detail也就是说这种传递参数的方式不会在url显示出来。并且这种方式不用修改路由的文件，写法参见方法二 那么在跳转路由的时候写成：1234this.$router.push(&#123;name: 'detail', params: &#123;id: 333&#125;&#125;);// 注意哦，看着跟方法二很像，差别有两个：push对象中path改成name，对应跳转组件的name；第二个参数对象名称为params 在获取参数id的时候，写法如下：1this.$route.params.id ———————美丽的分割线———————ps：以上都是开始学习vue的时候做的笔记，最近整理到博客上，也发现了其中的一些不足，慢慢完善","categories":[],"tags":[]},{"title":"初学vue总结","slug":"review-note","date":"2018-11-20T03:46:12.000Z","updated":"2018-12-04T03:49:10.099Z","comments":true,"path":"2018/11/20/review-note/","link":"","permalink":"http://yoursite.com/2018/11/20/review-note/","excerpt":"","text":"1.tempeletemplate不仅是模板最外面的标签，同时，它也可以作为一个普通的标签使用，为了保证ul-li结构下能够使子组件与li同级，写法如下： 可以使用 v-if 来控制部分区域的显示与隐藏时: *template不能与v-show一起使用2.子组件索引可以使用 ref 为子组件指定一个索引 ID，被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的$refs对象。如果在普通的DOM上使用，引用指向的就是DOM元素；如果用在子组件上，引用指向组件实例： (1)在普通页面使用时 在子组件上使用时：在父组件中使用子组件的方法，首先引用对象是this，其次由于页面使用v-for来渲染子组件，ref便是一个数组，通过被点击的index值来确定执行哪一个子组件的open方法。 3.传值(1)$emit传值 子组件给父组件传值,this.$emit(fun,pram)第一个参数为事件名，第二个参数为传入的数据，可以为对象，如下：123submit () &#123; this.$emit('inp', &#123;value: this.msg. imgs: ['img1', 'img2'])&#125; 1&lt;child ref=\"in\" v-model=\"li.state\" :str=\"str\" @inp=\"inp\"&gt;&lt;/child&gt; 在父组件引用子组件时添加一个函数，v-on:function = “function1”,其中function是在子组件使用的函数，function1是在父组件使用函数，相当于在子组件间触发方法inp时，父组件也将执行自身的inp方法。 (2)props传值 父组件给子组件传值，在子组件页面，在props属性中定义一个变量，声明变量的类型，访问时如同data属性中生命的变量一样，this.propA。 1props:['propA'] 又或者写成12345678910props:&#123; propA: &#123; type: String, required: true &#125;, propB: &#123; type: Number, default: 100 &#125;&#125; props可为数组亦可为对象，其实在props定义的变量就等于像在data函数中定义的变量，若是在props对象中定义的变量可以添加该变量的规定类型、默认值等一些校验。当 prop 验证失败的时候，(开发环境构建版本的) Vue 将会产生一个控制台的警告。 4.v-model(1)场景一：v-model在input元素中的使用 能够让p标签中的文字为输入框中实时输入的文字，首先在实例中声明变量，可以给一个默认值，也可为空；在模板中将p标签的文本内容用&#123;&#123; &#125;&#125;进行数据绑定，在输入框中用v-model绑定实例中声明的变量，实现数据的双向绑定，如下图: 事实上，在input标签中为如下图的缩写：1&lt;input v-bind:value=\"message\" v-on:input=\"message = $event.target.value\"&gt; 要想能够使v-model生效，接受一个 value 属性，在有新的值时触发 input 事件，input事件是html5新添加事件，每当输入框（input或textarea）的内容发生改变时，就会触发并将值传给message。 (1)场景二：v-model在组件上的使用更改子组件的值能实时更新父组件的值，在子组件中将值传给父组件，利用emit事件传值，用input作为触发事件的事件名，因为在子组件中的textarea的内容发生改变时，触发该事件。1this.$emit('input', &#123;value: this.msg, imgs:['image1', 'image2']&#125;) 在子组件中添加v-model属性时，默认会把value作为子组件的属性。1&lt;child v-model=\"li.state\"&gt;&lt;/child&gt; ——————————–分割线——————————– 对input事件以及父子组件之间传值的理解(1)父子组件传值若在子组件，emit写法如下：12345678910this.$emit('inp', &#123;value: this.msg, imgs:['image1', 'image2']&#125;)// 在父组件引用子组件如下：&lt;child v-model=\"li.state\" @inp=\"inp\"&gt;&lt;/child&gt;// 父组件中inp事件如下：inp (data) &#123; console.log(data)&#125;data便是emit事件的参数，并且将会把值传给li.state结果是：&#123;value: '111', imgs: Array(2)&#125; (2)对input事件的思考若子组件，emit写法如下：123this.$emit('input', &#123;value: this.msg, imgs:['image1', 'image2']&#125;)// 父组件下写法如下&lt;child v-model=\"li.state\" @input=\"inp\"&gt;&lt;/child&gt; 当子组件为input或textarea元素时，用v-model绑定在父组件中子组件时，emit事件以input为触发事件名，将返回的结果添加到input元素或textarea元素的value属性上，页面中声明的inp事件与本身子组件的内容发生改变所触发的input事件叠加，那么这个时候打印的date便是子组件中的value值，打印结果如下： 5.父子组件之间的双向绑定 12345678910 &lt;child v-model=\"li.state\" @inp=\"inp\" :str=\"str\"&gt;&lt;/child&gt; // 在子组件中的props属性定义一个变量，变量的名字随意，类型需要确定，如下： props: &#123; str: String, value: Object &#125;在子组件mounted方法时将值对页面中需要绑定的变量进行绑定，当父组件中的value有值时，将值赋值给子组件的变量，如下：mounted () &#123; if (this.value) this.msg = this.value.value&#125; 6.watch监听 当父组件中的值动态改变时，子组件需要监听才能进行实时改变，例如在父组件中设定一个延迟器，延迟改变值，如下： 12345678910111213 mounted () &#123; setTimeout (() =&gt; &#123; this.list[0].status.value = '异步' &#125;, 2000)&#125;// 在子组件中就需要利用监听事件，写法如下：watch: &#123; 'value.value' (val) &#123; if (val) this.msg = val.value &#125;&#125;// 由于数组结构如下，为了监听value值的变化，所以是value对象中的value属性，如果有值将值渲染到页面中list: [&#123;name:'任务', status: &#123;value: '222', imgs: []&#125;&#125;] 上边是watch监听一个属性，也可以监听一个对象，写法如下：`watch: { value: { handler: function (val) { if (val) this.msg = val.value }, deep: true }} 7.当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级———————美丽的分割线———————ps：以上都是开始学习vue的时候做的笔记，最近整理到博客上，也发现了其中的一些不足，慢慢完善","categories":[],"tags":[]},{"title":"vue-resource怎么写服务类","slug":"hello","date":"2018-11-17T06:56:23.035Z","updated":"2018-12-05T10:03:33.144Z","comments":true,"path":"2018/11/17/hello/","link":"","permalink":"http://yoursite.com/2018/11/17/hello/","excerpt":"","text":"vue-resource可以基于全局的Vue对象使用http（vue.http），也可以基于某个Vue实例使用http(this.$http)。 基于全局Vue对象使用http12Vue.http.get('/someUrl', [options]).then(successCallback, errorCallback);Vue.http.post('/someUrl', [body], [options]).then(successCallback, errorCallback); 在一个Vue实例内使用$http 12this.$http.get('/someUrl', [options]).then(successCallback, errorCallback);this.$http.post('/someUrl', [body], [options]).then(successCallback, errorCallback); 在发送请求后，使用then方法来处理响应结果，then方法有两个参数，第一个参数是响应成功时的回调函数，第二个参数是响应失败时的回调函数。 两种场景使用场景一 基于全局对象使用http（vue.http）1Vue.$http.get('/static/address/address.json').then(res =&gt; &#123; let list = res.body &#125;) 上边是请求本地的json文件，then方法中传入一个参数，响应成功时将返回的数据传到本地的数组中，response.body为返回的请求体。在实际项目开发过程中，用到的也是全局的，如下所示： 1let res =await $http.get('/static/address/address.json', &#123;params: param&#125;).then(res =&gt; res.json) 会发现没有写vue和this，但是事实是项目中对vue-resource进行了封装，所以直接$http直接可以代替全局的写法 场景二 基于某个vue组件使用http（this.$http）1234567created () &#123; this.$http.get('http://apis.baidu.com/tiyu', &#123; params: &#123;num: 10&#125; &#125;).then((res) =&gt; &#123;console.log(res.body)&#125;, (err)=&gt;&#123; console.log('出错') &#125;)&#125; 在一个组件中使用vue-resource时，将请求写在钩子函数中，大多数情况写在created钩子函数中。 ———————美丽的分割线———————ps：以上都是开始学习vue的时候做的笔记，最近整理到博客上，也发现了其中的一些不足，慢慢完善","categories":[],"tags":[]},{"title":"欢迎来踩踩","slug":"hello-world","date":"2018-11-16T02:16:00.239Z","updated":"2018-11-20T12:24:47.160Z","comments":true,"path":"2018/11/16/hello-world/","link":"","permalink":"http://yoursite.com/2018/11/16/hello-world/","excerpt":"","text":"开始整理一些之前学习和在项目中的笔记，这样就不用在多个客户端下载OneNote然后同步笔记、同步笔记、同步笔记！最开始都是刚刚参加的时候做的一些笔记以及项目总结，比较稚嫩，后边还是会注意质量的输出。来啦~~~","categories":[],"tags":[]},{"title":"get、post请求","slug":"review-note9","date":"2018-10-16T08:35:06.000Z","updated":"2019-01-17T13:02:05.318Z","comments":true,"path":"2018/10/16/review-note9/","link":"","permalink":"http://yoursite.com/2018/10/16/review-note9/","excerpt":"","text":"1. get、post概述get，post为两种请求方式，直观上的区别是，get的请求将请求的数据显示在url上，比如我在百度搜索’get’一词的时候，浏览器的URL地址变成：https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=0&amp;rsv_idx=1&amp;tn=baidu&amp;wd=get&amp;rsv_pq=afdd00d5000058f7&amp;rsv_t=94c5xvQi9LazQd58Y%2FTkD6Md5CXhxCNUEbxaryQAzTEGpOJ1J730WnTJboo&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_sug3=4&amp;rsv_sug1=3&amp;rsv_sug7=100&amp;rsv_sug2=0&amp;inputT=1659&amp;rsv_sug4=2475，以?分割URL和传输数据，参数之间以&amp;相连；post请求提交的数据则放置在是HTTP包的包体中。从而体现了get与post安全性的问题，比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1登录页面有可能被浏览器缓存或者其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了。 2.get请求限制由于GET是通过URL提交数据，那么GET可提交的数据量就跟URL的长度有直接关系了，而实际上，URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。理论来说，POST是没有大小限制的，HTTP协议规范也没有进行大小限制，起限制作用的是服务器的处理程序的处理能力。 3.get、post请求传递参数不同get传递参数的方式，能够看到首先定义一个对象，存放需要传递的参数，在进行get请求的时候，第一个参数为url地址，第二个参数为参数列表，以对象key:value的方式进行传递，post请求传递URl地址以及参数对象就可以了。 post请求1$http.post(API_HOST+'/scenery/adminInsertId', params).then(function (res) &#123;&#125;) get请求123$http.post(API_HOST+'/scenery/adminInsertId', &#123;params:params&#125;).then(function (res) &#123;&#125;)或者,若get请求只有一个参数的时候，也可以拼接在的url后边，参数为code：$http.get(API_HOST+'/session/getUserInfoByCode?code=' + code).then(function (res) &#123;&#125;)","categories":[],"tags":[]}]}