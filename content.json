{"meta":{"title":"WningLemon","subtitle":null,"description":null,"author":"WningLemon","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"初学vue总结","slug":"review-note","date":"2018-11-19T06:30:47.136Z","updated":"2018-11-20T12:20:13.829Z","comments":true,"path":"2018/11/19/review-note/","link":"","permalink":"http://yoursite.com/2018/11/19/review-note/","excerpt":"","text":"1.tempeletemplate不仅是模板最外面的标签，同时，它也可以作为一个普通的标签使用，为了保证ul-li结构下能够使子组件与li同级，写法如下： 可以使用 v-if 来控制部分区域的显示与隐藏时: *template不能与v-show一起使用2.子组件索引可以使用 ref 为子组件指定一个索引 ID，被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的$refs对象。如果在普通的DOM上使用，引用指向的就是DOM元素；如果用在子组件上，引用指向组件实例： (1)在普通页面使用时 在子组件上使用时：在父组件中使用子组件的方法，首先引用对象是this，其次由于页面使用v-for来渲染子组件，ref便是一个数组，通过被点击的index值来确定执行哪一个子组件的open方法。 3.传值(1)$emit传值 子组件给父组件传值,this.$emit(fun,pram)第一个参数为事件名，第二个参数为传入的数据，可以为对象，如下：123submit () &#123; this.$emit('inp', &#123;value: this.msg. imgs: ['img1', 'img2'])&#125; 1&lt;child ref=\"in\" v-model=\"li.state\" :str=\"str\" @inp=\"inp\"&gt;&lt;/child&gt; 在父组件引用子组件时添加一个函数，v-on:function = “function1”,其中function是在子组件使用的函数，function1是在父组件使用函数，相当于在子组件间触发方法inp时，父组件也将执行自身的inp方法。 (2)props传值 父组件给子组件传值，在子组件页面，在props属性中定义一个变量，声明变量的类型，访问时如同data属性中生命的变量一样，this.propA。 1props:['propA'] 又或者写成12345678910props:&#123; propA: &#123; type: String, required: true &#125;, propB: &#123; type: Number, default: 100 &#125;&#125; props可为数组亦可为对象，其实在props定义的变量就等于像在data函数中定义的变量，若是在props对象中定义的变量可以添加该变量的规定类型、默认值等一些校验。当 prop 验证失败的时候，(开发环境构建版本的) Vue 将会产生一个控制台的警告。 4.v-model(1)场景一：v-model在input元素中的使用 能够让p标签中的文字为输入框中实时输入的文字，首先在实例中声明变量，可以给一个默认值，也可为空；在模板中将p标签的文本内容用&#123;&#123; &#125;&#125;进行数据绑定，在输入框中用v-model绑定实例中声明的变量，实现数据的双向绑定，如下图: 事实上，在input标签中为如下图的缩写：1&lt;input v-bind:value=\"message\" v-on:input=\"message = $event.target.value\"&gt; 要想能够使v-model生效，接受一个 value 属性，在有新的值时触发 input 事件，input事件是html5新添加事件，每当输入框（input或textarea）的内容发生改变时，就会触发并将值传给message。 (1)场景二：v-model在组件上的使用更改子组件的值能实时更新父组件的值，在子组件中将值传给父组件，利用emit事件传值，用input作为触发事件的事件名，因为在子组件中的textarea的内容发生改变时，触发该事件。1this.$emit('input', &#123;value: this.msg, imgs:['image1', 'image2']&#125;) 在子组件中添加v-model属性时，默认会把value作为子组件的属性。1&lt;child v-model=\"li.state\"&gt;&lt;/child&gt; ——————————–分割线——————————– 对input事件以及父子组件之间传值的理解(1)父子组件传值若在子组件，emit写法如下：12345678910this.$emit('inp', &#123;value: this.msg, imgs:['image1', 'image2']&#125;)// 在父组件引用子组件如下：&lt;child v-model=\"li.state\" @inp=\"inp\"&gt;&lt;/child&gt;// 父组件中inp事件如下：inp (data) &#123; console.log(data)&#125;data便是emit事件的参数，并且将会把值传给li.state结果是：&#123;value: '111', imgs: Array(2)&#125; (2)对input事件的思考若子组件，emit写法如下：123this.$emit('input', &#123;value: this.msg, imgs:['image1', 'image2']&#125;)// 父组件下写法如下&lt;child v-model=\"li.state\" @input=\"inp\"&gt;&lt;/child&gt; 当子组件为input或textarea元素时，用v-model绑定在父组件中子组件时，emit事件以input为触发事件名，将返回的结果添加到input元素或textarea元素的value属性上，页面中声明的inp事件与本身子组件的内容发生改变所触发的input事件叠加，那么这个时候打印的date便是子组件中的value值，打印结果如下： 5.父子组件之间的双向绑定 12345678910 &lt;child v-model=\"li.state\" @inp=\"inp\" :str=\"str\"&gt;&lt;/child&gt; // 在子组件中的props属性定义一个变量，变量的名字随意，类型需要确定，如下： props: &#123; str: String, value: Object &#125;在子组件mounted方法时将值对页面中需要绑定的变量进行绑定，当父组件中的value有值时，将值赋值给子组件的变量，如下：mounted () &#123; if (this.value) this.msg = this.value.value&#125; 6.watch监听 当父组件中的值动态改变时，子组件需要监听才能进行实时改变，例如在父组件中设定一个延迟器，延迟改变值，如下： 12345678910111213 mounted () &#123; setTimeout (() =&gt; &#123; this.list[0].status.value = '异步' &#125;, 2000)&#125;// 在子组件中就需要利用监听事件，写法如下：watch: &#123; 'value.value' (val) &#123; if (val) this.msg = val.value &#125;&#125;// 由于数组结构如下，为了监听value值的变化，所以是value对象中的value属性，如果有值将值渲染到页面中list: [&#123;name:'任务', status: &#123;value: '222', imgs: []&#125;&#125;] 上边是watch监听一个属性，也可以监听一个对象，写法如下：`watch: { value: { handler: function (val) { if (val) this.msg = val.value }, deep: true }} 7.当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级———————美丽的分割线———————ps：以上都是开始学习vue的时候做的笔记，最近整理到博客上，也发现了其中的一些不足，慢慢完善","categories":[],"tags":[]},{"title":"vue-resource怎么写服务类","slug":"hexo-build","date":"2018-11-17T06:56:23.035Z","updated":"2018-11-20T12:21:01.164Z","comments":true,"path":"2018/11/17/hexo-build/","link":"","permalink":"http://yoursite.com/2018/11/17/hexo-build/","excerpt":"","text":"vue-resource可以基于全局的Vue对象使用http（vue.http），也可以基于某个Vue实例使用http(this.$http)。 基于全局Vue对象使用http12Vue.http.get('/someUrl', [options]).then(successCallback, errorCallback);Vue.http.post('/someUrl', [body], [options]).then(successCallback, errorCallback); 在一个Vue实例内使用$http 12this.$http.get('/someUrl', [options]).then(successCallback, errorCallback);this.$http.post('/someUrl', [body], [options]).then(successCallback, errorCallback); 在发送请求后，使用then方法来处理响应结果，then方法有两个参数，第一个参数是响应成功时的回调函数，第二个参数是响应失败时的回调函数。 两种场景使用场景一 基于全局对象使用http（vue.http）1Vue.$http.get('/static/address/address.json').then(res =&gt; &#123; let list = res.body &#125;) 上边是请求本地的json文件，then方法中传入一个参数，响应成功时将返回的数据传到本地的数组中，response.body为返回的请求体。在实际项目开发过程中，用到的也是全局的，如下所示： 1let res =await $http.get('/static/address/address.json', &#123;params: param&#125;).then(res =&gt; res.json) 会发现没有写vue和this，但是事实是项目中对vue-resource进行了封装，所以直接$http直接可以代替全局的写法 场景二 基于某个vue组件使用http（this.$http）1234567created () &#123; this.$http.get('http://apis.baidu.com/tiyu', &#123; params: &#123;num: 10&#125; &#125;).then((res) =&gt; &#123;console.log(res.body)&#125;, (err)=&gt;&#123; console.log('出错') &#125;)&#125; 在一个组件中使用vue-resource时，将请求写在钩子函数中，大多数情况写在created钩子函数中。 ———————美丽的分割线———————ps：以上都是开始学习vue的时候做的笔记，最近整理到博客上，也发现了其中的一些不足，慢慢完善","categories":[],"tags":[]},{"title":"欢迎来踩踩","slug":"hello-world","date":"2018-11-16T02:16:00.239Z","updated":"2018-11-20T12:24:47.160Z","comments":true,"path":"2018/11/16/hello-world/","link":"","permalink":"http://yoursite.com/2018/11/16/hello-world/","excerpt":"","text":"开始整理一些之前学习和在项目中的笔记，这样就不用在多个客户端下载OneNote然后同步笔记、同步笔记、同步笔记！最开始都是刚刚参加的时候做的一些笔记以及项目总结，比较稚嫩，后边还是会注意质量的输出。来啦~~~","categories":[],"tags":[]}]}